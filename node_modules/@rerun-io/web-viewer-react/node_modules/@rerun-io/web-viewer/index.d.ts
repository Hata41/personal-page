export type Panel = "top" | "blueprint" | "selection" | "time";
export type PanelState = "hidden" | "collapsed" | "expanded";
export type Backend = "webgpu" | "webgl";
export type VideoDecoder = "auto" | "prefer_software" | "prefer_hardware";
export interface WebViewerOptions {
    /** Url to the example manifest. Unused if `hide_welcome_screen` is set to `true`. */
    manifest_url?: string;
    /** The render backend used by the viewer. Either "webgl" or "webgpu". Prefers "webgpu". */
    render_backend?: Backend;
    /** Video decoder config used by the viewer. Either "auto", "prefer_software" or "prefer_hardware". */
    video_decoder?: VideoDecoder;
    /** If set to `true`, hides the welcome screen, which contains our examples. Defaults to `false`. */
    hide_welcome_screen?: boolean;
    /**
     * Allow the viewer to handle fullscreen mode.
     * This option sets canvas style so is not recommended if you are doing anything custom,
     * or are embedding the viewer in an iframe.
     *
     * Defaults to `false`.
     */
    allow_fullscreen?: boolean;
    /**
     * Enable the history feature of the viewer.
     *
     * This is only relevant when `hide_welcome_screen` is `false`,
     * as it's currently only used to allow going between the welcome screen and examples.
     *
     * Defaults to `false`.
     */
    enable_history?: boolean;
    /** The CSS width of the canvas. */
    width?: string;
    /** The CSS height of the canvas. */
    height?: string;
}
/**
 * The public interface is @see {WebViewerOptions}
 *
 * @private
 */
export interface AppOptions extends WebViewerOptions {
    url?: string;
    manifest_url?: string;
    video_decoder?: VideoDecoder;
    render_backend?: Backend;
    hide_welcome_screen?: boolean;
    panel_state_overrides?: Partial<{
        [K in Panel]: PanelState;
    }>;
    fullscreen?: FullscreenOptions;
    enable_history?: boolean;
}
interface FullscreenOptions {
    get_state: () => boolean;
    on_toggle: () => void;
}
interface WebViewerEvents {
    fullscreen: boolean;
    ready: void;
}
type EventsWithValue = {
    [K in keyof WebViewerEvents as WebViewerEvents[K] extends void ? never : K]: WebViewerEvents[K];
};
type EventsWithoutValue = {
    [K in keyof WebViewerEvents as WebViewerEvents[K] extends void ? K : never]: WebViewerEvents[K];
};
type Cancel = () => void;
export declare class WebViewer {
    #private;
    constructor();
    /**
     * Start the viewer.
     *
     * @param rrd URLs to `.rrd` files or WebSocket connections to our SDK.
     * @param parent The element to attach the canvas onto.
     * @param options Whether to hide the welcome screen.
     */
    start(rrd: string | string[] | null, parent: HTMLElement | null, options: WebViewerOptions | null): Promise<void>;
    /**
     * Register an event listener.
     *
     * Returns a function which removes the listener when called.
     */
    on<E extends keyof EventsWithValue>(event: E, callback: (value: EventsWithValue[E]) => void): Cancel;
    on<E extends keyof EventsWithoutValue>(event: E, callback: () => void): Cancel;
    /**
     * Register an event listener which runs only once.
     *
     * Returns a function which removes the listener when called.
     */
    once<E extends keyof EventsWithValue>(event: E, callback: (value: EventsWithValue[E]) => void): Cancel;
    once<E extends keyof EventsWithoutValue>(event: E, callback: () => void): Cancel;
    /**
     * Unregister an event listener.
     *
     * The event emitter relies on referential equality to store callbacks.
     * The `callback` passed in must be the exact same _instance_ of the function passed in to `on` or `once`.
     */
    off<E extends keyof EventsWithValue>(event: E, callback: (value: EventsWithValue[E]) => void): void;
    off<E extends keyof EventsWithoutValue>(event: E, callback: () => void): void;
    /**
     * The underlying canvas element.
     */
    get canvas(): HTMLCanvasElement | null;
    /**
     * Returns `true` if the viewer is ready to connect to data sources.
     */
    get ready(): boolean;
    /**
     * Open a recording.
     *
     * The viewer must have been started via `WebViewer.start`.
     *
     * @param rrd URLs to `.rrd` files or WebSocket connections to our SDK.
     * @param options
     *        - follow_if_http: Whether Rerun should open the resource in "Following" mode when streaming
     *        from an HTTP url. Defaults to `false`. Ignored for non-HTTP URLs.
     */
    open(rrd: string | string[], options?: {
        follow_if_http?: boolean;
    }): void;
    /**
     * Close a recording.
     *
     * The viewer must have been started via `WebViewer.start`.
     *
     * @param rrd URLs to `.rrd` files or WebSocket connections to our SDK.
     */
    close(rrd: string | string[]): void;
    /**
     * Stop the viewer, freeing all associated memory.
     *
     * The same viewer instance may be started multiple times.
     */
    stop(): void;
    /**
     * Opens a new channel for sending log messages.
     *
     * The channel can be used to incrementally push `rrd` chunks into the viewer.
     *
     * @param channel_name used to identify the channel.
     */
    open_channel(channel_name?: string): LogChannel;
    /**
     * Force a panel to a specific state.
     *
     * @param panel
     * @param state
     */
    override_panel_state(panel: Panel, state: PanelState): void;
    /**
     * Toggle panel overrides set via `override_panel_state`.
     *
     * @param value - set to a specific value. Toggles the previous value if not provided.
     */
    toggle_panel_overrides(value?: boolean | null): void;
    /**
     * Toggle fullscreen mode.
     *
     * This does nothing if `allow_fullscreen` was not set to `true` when starting the viewer.
     *
     * Fullscreen mode works by updating the underlying `<canvas>` element's `style`:
     * - `position` to `fixed`
     * - width/height/top/left to cover the entire viewport
     *
     * When fullscreen mode is toggled off, the style is restored to its previous values.
     *
     * When fullscreen mode is toggled on, any other instance of the viewer on the page
     * which is already in fullscreen mode is toggled off. This means that it doesn't
     * have to be tracked manually.
     *
     * This functionality can also be directly accessed in the viewer:
     * - The maximize/minimize top panel button
     * - The `Toggle fullscreen` UI command (accessible via the command palette, CTRL+P)
     */
    toggle_fullscreen(): void;
}
export declare class LogChannel {
    #private;
    /**
     * @param on_send
     * @param on_close
     * @param get_state
     */
    constructor(on_send: (data: Uint8Array) => void, on_close: () => void, get_state: () => "ready" | "starting" | "stopped");
    get ready(): boolean;
    /**
     * Send an `rrd` containing log messages to the viewer.
     *
     * Does nothing if `!this.ready`.
     *
     * @param rrd_bytes Is an rrd file stored in a byte array, received via some other side channel.
     */
    send_rrd(rrd_bytes: Uint8Array): void;
    /**
     * Close the channel.
     *
     * Does nothing if `!this.ready`.
     */
    close(): void;
}
export {};
//# sourceMappingURL=index.d.ts.map